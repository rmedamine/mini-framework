# EXPLICATION DÉTAILLÉE - diff.js
# =================================

## SYSTÈME DE DIFFING - Moteur de performance
Le système de diffing compare les arbres virtuels pour mettre à jour uniquement les parties du DOM qui ont changé.

## CACHE DES ÉLÉMENTS
const elementCache = new WeakMap()

LIGNE 2: Cache global pour stocker les arbres virtuels précédents
- WeakMap: Permet au garbage collector de nettoyer automatiquement
- Clé: élément DOM, Valeur: arbre virtuel précédent

## FONCTION normalizeChildren() - Normalisation des enfants
function normalizeChildren(children) {
  if (!Array.isArray(children)) {
    children = [children]
  }
  
  return children.filter(child => 
    child !== false && 
    child !== null && 
    child !== undefined
  )
}

LIGNE 4-12: Fonction pour normaliser les enfants
- LIGNE 5-7: Si children n'est pas un tableau, le convertir en tableau
- LIGNE 9-12: Filtrer les éléments conditionnels (false, null, undefined)
- UTILISATION: Transforme [el1, false, el2] en [el1, el2]

## FONCTION diffAndUpdateChildren() - Diffing des enfants
export function diffAndUpdateChildren(parent, oldChildren, newChildren) {
  const normalizedOldChildren = normalizeChildren(oldChildren)
  const normalizedNewChildren = normalizeChildren(newChildren)
  
  const oldLength = normalizedOldChildren.length
  const newLength = normalizedNewChildren.length

LIGNE 15-22: Fonction principale pour comparer et mettre à jour les enfants
- LIGNE 16-17: Normaliser les anciens et nouveaux enfants
- LIGNE 19-20: Calculer les longueurs pour la comparaison

  // Si les longueurs sont différentes, on doit gérer les ajouts/suppressions
  if (oldLength !== newLength) {
    // Supprimer les enfants en trop
    while (parent.children.length > newLength) {
      parent.removeChild(parent.lastChild)
    }
    
    // Ajouter les nouveaux enfants
    for (let i = oldLength; i < newLength; i++) {
      const newElement = createElement(normalizedNewChildren[i])
      if (newElement) {
        parent.appendChild(newElement)
      }
    }
  }

LIGNE 24-37: Gestion des changements de longueur
- LIGNE 25: Si le nombre d'enfants a changé
- LIGNE 27-29: Supprimer les enfants en trop (de la fin)
- LIGNE 31-36: Ajouter les nouveaux enfants manquants

  // Mettre à jour les enfants existants
  const minLength = Math.min(oldLength, newLength)
  for (let i = 0; i < minLength; i++) {
    updateChild(parent, i, normalizedOldChildren[i], normalizedNewChildren[i])
  }
}

LIGNE 39-43: Mise à jour des enfants existants
- LIGNE 40: Calculer la longueur minimale pour la comparaison
- LIGNE 41-43: Mettre à jour chaque enfant existant

## FONCTION updateChild() - Mise à jour d'un enfant spécifique
function updateChild(parent, index, oldChild, newChild) {
  const domChild = parent.children[index]
  
  // Si les types sont différents, remplacer complètement
  if (typeof oldChild !== typeof newChild || 
      (typeof oldChild === 'object' && oldChild.type !== newChild.type)) {
    const newElement = createElement(newChild)
    if (newElement) {
      parent.replaceChild(newElement, domChild)
    }
    return
  }

LIGNE 46-56: Fonction pour mettre à jour un enfant spécifique
- LIGNE 47: Récupérer l'élément DOM enfant
- LIGNE 49-55: Si le type a changé, remplacer complètement l'élément
- LIGNE 56: Sortir de la fonction après remplacement

  // Si c'est du texte, mettre à jour directement
  if (typeof oldChild === 'string') {
    if (oldChild !== newChild) {
      const textNode = parent.childNodes[index]
      if (textNode && textNode.nodeType === Node.TEXT_NODE) {
        textNode.textContent = newChild
      }
    }
    return
  }

LIGNE 58-66: Gestion des nœuds texte
- LIGNE 59: Si c'est du texte
- LIGNE 60-65: Si le contenu a changé, mettre à jour directement
- LIGNE 66: Sortir après mise à jour du texte

  // Mettre à jour les propriétés de l'élément
  updateElementProps(domChild, oldChild.props || {}, newChild.props || {})
  
  // Mettre à jour les enfants
  const oldChildren = oldChild.props?.children || []
  const newChildren = newChild.props?.children || []
  diffAndUpdateChildren(domChild, oldChildren, newChildren)
}

LIGNE 68-73: Mise à jour des propriétés et enfants
- LIGNE 69: Mettre à jour les propriétés de l'élément
- LIGNE 71-73: Mettre à jour récursivement les enfants

## FONCTION updateElementProps() - Mise à jour des propriétés
function updateElementProps(element, oldProps, newProps) {
  // Supprimer les propriétés qui n'existent plus
  for (const key in oldProps) {
    if (key === 'children') continue
    if (!(key in newProps)) {
      removeProp(element, key, oldProps[key])
    }
  }

LIGNE 76-83: Fonction pour mettre à jour les propriétés d'un élément
- LIGNE 78-82: Supprimer les propriétés qui n'existent plus dans newProps
- LIGNE 79: Ignorer la propriété 'children' (gérée séparément)

  // Ajouter ou mettre à jour les propriétés
  for (const key in newProps) {
    if (key === 'children') continue
    if (!(key in oldProps) || oldProps[key] !== newProps[key]) {
      setProp(element, key, newProps[key])
    }
  }
}

LIGNE 85-91: Ajout/mise à jour des propriétés
- LIGNE 86-90: Pour chaque propriété dans newProps
- LIGNE 87: Ignorer 'children'
- LIGNE 88-90: Si la propriété est nouvelle ou a changé, la définir

## FONCTION removeProp() - Suppression de propriété
function removeProp(element, key, value) {
  if (key.startsWith('on') && typeof value === 'function') {
    const event = key.slice(2).toLowerCase()
    element[`on${event}`] = null
  } else if (key === 'class') {
    element.className = ''
  } else if (key === 'checked') {
    element.checked = false
  } else if (key === 'value') {
    // Pour les éléments input, vider la propriété value
    element.value = ''
  } else {
    element.removeAttribute(key)
  }
}

LIGNE 94-108: Fonction pour supprimer une propriété
- LIGNE 95-98: Si c'est un événement, le détacher
- LIGNE 99-101: Si c'est 'class', vider className
- LIGNE 102-104: Si c'est 'checked', mettre à false
- LIGNE 105-107: Si c'est 'value', vider la valeur
- LIGNE 108-110: Sinon, supprimer l'attribut

## FONCTION setProp() - Définition de propriété
function setProp(element, key, value) {
  if (key.startsWith('on') && typeof value === 'function') {
    const event = key.slice(2).toLowerCase()
    element[`on${event}`] = value
  } else if (key === 'class') {
    element.className = value
  } else if (key === 'checked') {
    element.checked = value
  } else if (key === 'value') {
    // Pour les éléments input, définir directement la propriété value
    element.value = value
  } else {
    element.setAttribute(key, value)
  }
}

LIGNE 113-127: Fonction pour définir une propriété
- LIGNE 114-117: Si c'est un événement, l'attacher
- LIGNE 118-120: Si c'est 'class', définir className
- LIGNE 121-123: Si c'est 'checked', définir la propriété
- LIGNE 124-126: Si c'est 'value', définir la valeur
- LIGNE 127-129: Sinon, utiliser setAttribute

## FONCTION createElement() - Création d'élément DOM
function createElement(virtualElement) {
  if (typeof virtualElement === 'string') {
    return document.createTextNode(virtualElement)
  }
  
  if (virtualElement === false || virtualElement === null || virtualElement === undefined) {
    return null
  }
  
  const element = document.createElement(virtualElement.type)
  const props = virtualElement.props || {}

LIGNE 132-142: Fonction pour créer un élément DOM depuis un élément virtuel
- LIGNE 133-135: Si c'est une chaîne, créer un nœud texte
- LIGNE 137-139: Si c'est falsy, retourner null
- LIGNE 141-142: Créer l'élément et récupérer ses propriétés

  // Appliquer les propriétés
  for (const [key, value] of Object.entries(props)) {
    if (key === 'children') continue
    setProp(element, key, value)
  }

LIGNE 144-148: Application des propriétés
- LIGNE 145-147: Pour chaque propriété, l'appliquer
- LIGNE 146: Ignorer 'children' (géré séparément)

  // Ajouter les enfants
  const children = props.children || []
  const normalizedChildren = normalizeChildren(children)
  for (const child of normalizedChildren) {
    const childElement = createElement(child)
    if (childElement) {
      element.appendChild(childElement)
    }
  }
  
  return element
}

LIGNE 150-159: Ajout des enfants
- LIGNE 151-152: Récupérer et normaliser les enfants
- LIGNE 153-157: Créer et ajouter chaque enfant
- LIGNE 159: Retourner l'élément complet

## FONCTION diffAndUpdate() - Fonction principale de diffing
export function diffAndUpdate(parent, oldVirtualTree, newVirtualTree) {
  if (!oldVirtualTree) {
    // Premier rendu
    parent.innerHTML = ''
    const newElement = createElement(newVirtualTree)
    if (newElement) {
      parent.appendChild(newElement)
    }
  } else {
    // Mise à jour avec diffing
    updateChild(parent, 0, oldVirtualTree, newVirtualTree)
  }
}

LIGNE 162-173: Fonction principale du système de diffing
- LIGNE 163-169: Si pas d'ancien arbre (premier rendu), créer tout
- LIGNE 170-172: Sinon, utiliser le diffing pour mettre à jour

## FONCTIONS DE CACHE
export function getCachedTree(element) {
  return elementCache.get(element) || null
}

export function setCachedTree(element, tree) {
  elementCache.set(element, tree)
}

LIGNE 176-182: Fonctions pour gérer le cache
- LIGNE 177-179: Récupérer l'arbre virtuel depuis le cache
- LIGNE 181-183: Stocker l'arbre virtuel dans le cache

## UTILISATION PRATIQUE
======================

1. PREMIER RENDU:
   diffAndUpdate(container, null, newTree)

2. MISE À JOUR:
   diffAndUpdate(container, oldTree, newTree)

3. AVANTAGES:
   - Seul le texte qui change est mis à jour
   - Les éléments conditionnels sont gérés automatiquement
   - Performance optimisée pour les listes

## EXEMPLE DE PERFORMANCE
========================

AVANT (sans diffing):
```javascript
container.innerHTML = ''  // Supprime tout
container.appendChild(newElement)  // Recrée tout
```

APRÈS (avec diffing):
```javascript
// Seul le texte "Hello" → "World" est mis à jour
textNode.textContent = "World"
```

## ALGORITHME DE DIFFING
========================

1. COMPARAISON DES TYPES: Si différent → remplacement complet
2. COMPARAISON DU TEXTE: Si différent → mise à jour du contenu
3. COMPARAISON DES PROPRIÉTÉS: Ajout/suppression/mise à jour
4. COMPARAISON DES ENFANTS: Récursion pour chaque enfant
5. GESTION DES LONGUEURS: Ajout/suppression d'éléments 